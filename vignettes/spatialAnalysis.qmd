---
title: "Unlocking single cell spatial omics analyses with scdney"
params:
  test: FALSE
author:
- name: Shreya Rao
  affiliation:  
  - &WIMR Westmead Institute for Medical Research, Australia
  - School of Mathematics and Statistics, University of Sydney, Australia
  - Sydney Precision Data Science Centre, University of Sydney, Australia
- name: Ellis Patrick
  affiliation:
  - &WIMR Westmead Institute for Medical Research, Australia
  - School of Mathematics and Statistics, University of Sydney, Australia
  - Sydney Precision Data Science Centre, University of Sydney, Australia
date: 24 June 2025
vignette: >
  %\VignetteIndexEntry{"Introduction to a spicy workflow"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  BiocStyle::html_document
---


```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(BiocStyle)
```

# Version Info

<p>
**R version**: `r R.version.string`
<br />
**Bioconductor version**: `r BiocManager::version()`
<br />

# Introduction


# Loading R packages

```{r load libraries, echo=FALSE, results="hide", warning=FALSE}
suppressPackageStartupMessages({
  library(cytomapper)
  library(dplyr)
  library(ggplot2)
  library(simpleSeg)
  library(FuseSOM)
  library(ggpubr)
  library(scater)
  library(spicyR)
  library(ClassifyR)
  library(lisaClust)
  library(tidySpatialExperiment)
  library(treekoR)
  library(Statial)
  library(scFeatures)
})
```

```{r, eval=FALSE}
library(cytomapper)
library(dplyr)
library(ggplot2)
library(simpleSeg)
library(FuseSOM)
library(ggpubr)
library(scater)
library(spicyR)
library(ClassifyR)
library(lisaClust)
library(tidySpatialExperiment)
library(treekoR)
library(Statial)
library(scFeatures)
```


# Global paramaters

It is convenient to set the number of cores for running code in parallel. Please choose a number that is appropriate for your resources. Set the `use_mc` flag to `TRUE` if you would like to use parallel processing for the rest of the vignette. A minimum of 2 cores is suggested since running this workflow is rather computationally intensive.

```{r set parameters}
use_mc <- TRUE

if (use_mc) {
  nCores <- max(floor((parallel::detectCores() - 1)/2), 1)
} else {
  nCores <- 1
}
BPPARAM <- simpleSeg:::generateBPParam(nCores)

theme_set(theme_classic())
```

# Context

In the following we will re-analyse some MIBI-TOF data [(Risom et al, 2022)](https://www.sciencedirect.com/science/article/pii/S0092867421014860?via%3Dihub#!) profiling the spatial landscape of ductal carcinoma in situ (DCIS), which is a pre-invasive lesion that is thought to be a precursor to invasive breast cancer (IBC). The key conclusion of this manuscript (amongst others) is that spatial information about cells can be used to predict disease progression in patients. 


# Read in images

The images are stored in the `images` folder within the `data` folder. Here we use `loadImages()` from the `cytomapper` package to load all the tiff images into a `CytoImageList` object and store the images as h5 file on-disk.


```{r load images}
pathToImages <- system.file("extdata/images", package = "spicyWorkflow")

# Store images in a CytoImageList on_disk as h5 files to save memory.
images <- cytomapper::loadImages(
  pathToImages,
  single_channel = TRUE,
  on_disk = TRUE,
  h5FilesPath = HDF5Array::getHDF5DumpDir(),
  BPPARAM = BPPARAM,
  as.is = TRUE
)
gc()
```




# Load the clinical data

To associate features in our image with disease progression, it is important to read in information which links image identifiers to their progression status. We will do this here, making sure that our `imageID` match.
## Read the clinical data
```{r load clincal data}
# Read in clinical data, manipulate imageID and select columns
clinical <- read.csv(
  system.file(
    "extdata/1-s2.0-S0092867421014860-mmc1.csv",
    package = "spicyWorkflow"
  )
)

clinical <- clinical |>
  mutate(imageID = paste0(
    "Point", PointNumber, "_pt", Patient_ID, "_", TMAD_Patient
  ))

image_idx <- grep("normal", clinical$Tissue_Type)
clinical$imageID[image_idx] <- paste0(clinical$imageID[image_idx], "_Normal")

clinicalVariables <- c(
  "imageID", "Patient_ID", "Status", "Age", "SUBTYPE", "PAM50", "Treatment",
  "DCIS_grade", "Necrosis"
)

clinical$Status <- factor(clinical$Status)
rownames(clinical) <- clinical$imageID
```




## Put the clinical data into the colData of CytoImageList

We can then store the clinical information in the `mcols` of the `CytoImageList`.
```{r add clinical data}
# Add the clinical data to mcols of images.
mcols(images) <- clinical[names(images), clinicalVariables]
```






# Where are the cells in the images?



## Run simpleSeg


```{r segment}
# Generate segmentation masks
masks <- simpleSeg(
  images,
  nucleus = c("HH3"),
  cellBody = "dilate",
  transform = c("tissueMask","sqrt"),
  sizeSelection = 20,
  discSize = 5,
  cores = nCores
)
```


## Visualise separation


```{r visualise segmentation}
# Visualise segmentation performance one way.
EBImage::display(colorLabels(masks[[1]]))
```

## Visualise outlines


```{r}
# Visualise segmentation performance another way.
cytomapper::plotPixels(
  image = images[1],
  mask = masks[1],
  img_id = "imageID",
  colour_by = c("PanKRT", "HH3", "CD3", "CD20"),
  display = "single",
  colour = list(
    HH3 = c("black", "blue"),
    CD3 = c("black", "green"),
    CD20 = c("black", "red"),
    PanKRT = c("black", "yellow")
  ),
  bcg = list(
    HH3 = c(0, 1, 1.5),
    CD3 = c(0, 1, 3),
    CD20 = c(0, 1, 3),
    PanKRT = c(0, 1, 1.5)
  ),
  legend = NULL
)
```


# Summarise cell features.

In order to characterise the phenotypes of each of the segmented cells, `measureObjects` from `cytomapper` will calculate the average intensity of each channel within each cell as well as a few morphological features. The channel intensities will be stored in the `counts assay` in a `SpatialExperiment`. Information on the spatial location of each cell is stored in `colData` in the `m.cx` and `m.cy` columns. In addition to this, it will propagate the information we have store in the `mcols` of our `CytoImageList` in the `colData` of the resulting `SpatialExperiment`. 

```{r}
# Summarise the expression of each marker in each cell
cells <- cytomapper::measureObjects(
  masks,
  images,
  img_id = "imageID",
  return_as = "sce",
  feature_types = c("basic", "moment"),
  BPPARAM = BPPARAM
)

cells <- cells |> filter(!imageID %in% c('Point6103_pt1008_20624', 'Point6203_pt1107_31568', 'Point6206_pt1197_31571', 'Point6201_pt1027_20597'))
```



# How can we make marker quantification comparable across images?


```{r, fig.width=5, fig.height=5}
# Extract marker data and bind with information about images
df <- as.data.frame(cbind(colData(cells), t(assay(cells, "counts"))))

# Plots densities of CK7 for each image.
ggplot(df, aes(x = CK7, colour = imageID)) +
  geom_density() +
  theme(legend.position = "none")
```

We can transform and normalise our data using the `normalizeCells` function. Here we have taken the intensities from the `counts` assay, performed a square root transform, then for each image trimmed the 99 quantile and min-max scaled to 0-1. This modified data is then stored in the `norm` assay by default. We can see that this normalised data appears more bimodal, not perfectly, but likely to a sufficient degree for clustering.


```{r, fig.width=5, fig.height=5}
# Transform and normalise the marker expression of each cell type.
# Use a  arc-sine transform, then trimmed the 99 quantile and then remove first principal component
cells <- normalizeCells(cells,
  transformation = "asinh",
  method = c("trim99", "minMax", "PC1"),
  assayIn = "counts",
  cores = nCores
)

# Extract normalised marker information.
norm_df <- as.data.frame(cbind(colData(cells), t(assay(cells, "norm"))))


# Plots densities of normalised CK7 for each image.
ggplot(norm_df, aes(x = CK7, colour = imageID)) +
  geom_density() +
  theme(legend.position = "none")
```



# What types of cells are in my images?


## Use clustering

Clustering separates variation in data. Specifically choosing markers 

```{r FuseSOM}
# The markers used in the original publication to gate cell types.
useMarkers <- c(
  # Epithelial/tumour markers
  "PanKRT",       # Pan-cytokeratin: general epithelial marker (tumour or normal epithelium)
  "ECAD",         # E-cadherin: adherens junctions, epithelial cell integrity; also seen in myoepithelium
  "CK7",          # Cytokeratin 7: luminal epithelial marker
  "VIM",          # Vimentin: mesenchymal marker; high in fibroblasts, EMT tumour cells, and endothelium

  # Stromal markers
  "FAP",          # Fibroblast activation protein: cancer-associated fibroblasts (CAFs)
  "CD31",         # PECAM1: endothelial cell marker (blood vessels)
  "CK5",          # Cytokeratin 5: basal epithelial and myoepithelial marker
  "SMA",          # Smooth muscle actin: myoepithelial cells and myofibroblasts

  # Immune lineage marker
  "CD45",         # Pan-leukocyte marker: expressed on all immune cells

  # T cells
  "CD4",          # Helper T cells: subset of CD3+ T cells
  "CD3",          # T cell receptor complex: all T cells
  "CD8",          # Cytotoxic T cells: subset of CD3+ T cells

  # B cells
  "CD20",         # B cell marker: mature B cells

  # Myeloid/antigen-presenting cells
  "CD68",         # Macrophage marker: especially tumour-associated macrophages
  "CD14",         # Monocyte marker: also on some dendritic cells
  "CD11c",        # Myeloid dendritic cells: also on monocyte-derived DCs and some macrophages
  "HLADRDPDQ",    # MHC class II: antigen presentation, expressed on DCs, macrophages, B cells

  # Granulocytes and mast cells
  "MPO",          # Myeloperoxidase: neutrophils and granulocytes
  "Tryptase"      # Mast cells: granule content marker, specific for mast cells
)

```


Here we cluster using the `runFuseSOM` function. We have chosen to specify the same subset of markers used in the original manuscript for gating cell types. We have also specified the number of clusters to identify to be `numClusters = 21`. In addition to this, while FuseSOM can automatically estimate a grid size for the self organising map.


```{r}
# Set seed.
set.seed(51773)

cells@metadata <- list()

# Generate SOM and cluster cells into 21 groups.
cells <- runFuseSOM(
  cells,
  markers = useMarkers,
  assay = "norm",
  numClusters = 16
)

cells$cellType <- cells$clusters
```


## Check how many clusters should be used.

We can check to see how reasonable our choice of 21 clusters is using the `estimateNumCluster` and the `optiPlot` functions. Here we examine the Gap method, others such as Silhouette and Within Cluster Distance are also available.

As we can be seen below, we chose the second elbow point as the optimal number of clusters.


```{r}
cells <- estimateNumCluster(cells, kSeq = 2:30)
optiPlot(cells, method = "gap")
```

## Attempt to interpret the phenotype of each cluster

We can begin the process of understanding what each of these cell clusters are by using the `plotGroupedHeatmap` function from `scater`. At the least, here we can see we capture all the major immune populations that we expect to see.

```{r}
# Visualise marker expression in each cluster.
scater::plotGroupedHeatmap(
  cells,
  features = useMarkers,
  group = "clusters",
  exprs_values = "norm",
  center = TRUE,
  scale = TRUE,
  zlim = c(-3, 3),
  cluster_rows = FALSE,
  block = "clusters"
)
```




```{r}
# Can we use mutate instead?

cells$cellType <- cells |>
  colData() |>
  as.data.frame() |>
  mutate(cellType = factor(case_when(
      clusters == "cluster_1" ~ "Tumour",
      clusters == "cluster_2" ~ "T_cell_CD4",
      clusters == "cluster_3" ~ "T_cell_CD8",
      clusters == "cluster_4" ~ "Granulocytes",
      clusters == "cluster_5" ~ "B_cells",
      clusters == "cluster_6" ~ "DC",
      clusters == "cluster_7" ~ "Myoepthilial",
      clusters == "cluster_8" ~ "Monocyte",
      clusters == "cluster_9" ~ "OtherImmune",
      clusters == "cluster_10" ~ "Fibroblast",
      clusters == "cluster_11" ~ "OtherImmune",
      clusters == "cluster_12" ~ "Macrophage",
      clusters == "cluster_13" ~ "Endothelial",
      clusters == "cluster_14" ~ "Mast",
      clusters == "cluster_15" ~ "Endothelial",
      clusters == "cluster_16" ~ "Myoepthilial",
      TRUE ~ clusters
  ))) |> 
  pull(cellType) 
  
```



## Check cluster frequencies

We find it always useful to check the number of cells in each cluster. Here we can see that cluster 2 is contains lots of (most likely tumour) cells and cluster 10 contains very few cells.

```{r}
# Check cluster frequencies.
colData(cells)$cellType |>
  table() |>
  sort()
```






## Check em out on an image

```{r}
reducedDim(cells, "spatialCoords") <- cbind(x = cells$m.cx, y = cells$m.cy)

cells |> 
  #filter(imageID == "Point2203_pt1072_31606") |> 
  filter(imageID == "Point2206_pt1116_31620") |>
  plotReducedDim("spatialCoords", colour_by = "cellType")

```

```{r}

cells |> 
  join_features(features = c("ECAD"), assay = "norm", shape = "wide") |>
  ggplot(aes(x = cellType, y = ECAD)) + geom_boxplot()

```


## Dimension reduction

As our data is stored in a `SingleCellExperiment` we can also use `scater` to perform and visualise our data in a lower dimension to look for cluster differences.

```{r}
set.seed(51773)
# Perform dimension reduction using UMP.
cells <- scater::runUMAP(
  cells,
  subset_row = useMarkers,
  exprs_values = "norm"
)

# Select a subset of images to plot.
someImages <- unique(colData(cells)$imageID)[c(1, 10, 20, 40, 50, 60)]


# UMAP by cell type cluster.
scater::plotReducedDim(
  cells[, colData(cells)$imageID %in% someImages],
  dimred = "UMAP",
  colour_by = "clusters"
)
```


# Are there cell types that are more or less abundant with disease status?

We recommend using a package such as `diffcyt` for testing for changes in abundance of cell types. However, the `colTest` function allows us to quickly test for associations between the proportions of the cell types and progression status using either Wilcoxon rank sum tests or t-tests. Here we see a p-value less than 0.05, but this does not equate to a small FDR.

```{r}
# Select cells which belong to individuals with progressor status.
cellsToUse <- cells$Status %in% c("nonprogressor","progressor") &
  cells$PAM50 == "LumB" & !is.na(cells$PAM50)
#cells$Status %in% c("nonprogressor", "progressor")

# Perform simple wicoxon rank sum tests on the columns of the proportion matrix.
testProp <- colTest(cells[, cellsToUse],
  condition = "Status",
  feature = "cellType"
)

testProp
```

```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"] %in% c("nonprogressor", "progressor")]

prop <- getProp(cells[,cellsToUse], feature = "cellType")
clusterToUse <- rownames(testProp)[1]

boxplot(prop[imagesToUse, clusterToUse] ~ droplevels(clinical[imagesToUse, "Status"]))
```


# Do spatial relationships between cell types change?

## We see CD8 t cells becoming closer to a tumour cell subset in progressors

```{r}
# Test for changes in pair-wise spatial relationships between cell types.

spicyTest <- spicy(
  cells[, cellsToUse],
  condition = "Status",
  cellType = "cellType",
  imageID = "imageID",
  spatialCoords = c("m.cx","m.cy"),
  r = 50,
  sigma = 20,
  cores = nCores
)

topPairs(spicyTest, n = 20)
```







We can visualise these tests using `signifPlot` where we observe that cell type pairs appear to become less attractive (or avoid more) in the progression sample.

```{r}
# Visualise which relationships are changing the most.
signifPlot(
  spicyTest,
  breaks = c(-1.5, 3, 0.5)
)
```

## Add in nearest neighbours approach

# Are tumour cells closer to CD8 t cells than other t cells in progressors?

```{r}

set.seed(51773)
# Calculate hierarchy using treekoR
# clusterTree <- treekoR::getClusterTree(t(assay(cells, "norm")[useMarkers[useMarkers!="CD45"],]),
#                             cells$cellType,
#                             hierarchy_method="complete",
#                             hopach_K = 5,
#                             hopach_kmax = 10,
#                             scale = FALSE)
# 
# # Convert treekoR result to a name list of parents and children.
# treekorParents = getParentPhylo(clusterTree)

treekorParents <- list(T_cell = c("T_cell_CD8", "T_cell_CD4"), Immune = c("B_cells", "T_cell_CD8", "T_cell_CD4", "Granulocytes", "OtherImmune", "Mast", "Macrophage", "Monocyte", "DC"))

#treekorParents <- list(T_cell = c("cluster_2", "cluster_3"), Immune = c("cluster_2","cluster_3","cluster_4","cluster_5","cluster_6","cluster_8", "cluster_9","cluster_11", "cluster_13"))



parentDf <- parentCombinations(
  all = as.character(unique(cells$cellType)),
  parentList = treekorParents
)

#cells$cellTypeChar <- as.character(cells$cellType)

kontextualResult <- Kontextual(
  cells = cells[, cellsToUse],
  parentDf = parentDf,
  r = 100,
  cellType = "cellType",
  spatialCoords = c("m.cx","m.cy"),
  cores = nCores
)

```




```{r}

kontextMat <- prepMatrix(kontextualResult)

kontextResults <- colTest(kontextMat[rownames(prop), ], as.character(clinical[rownames(prop), "Status"]))

head(kontextResults)
```




# Are there any broad spatial domains associated with progression?


## Tweak settings a bit
```{r}
set.seed(51773)

# Cluster cells into spatial regions with similar composition.
cells <- lisaClust(
  cells,
  k = 4,
  r = c(20,50,100),
  sigma = 20,
  spatialCoords = c("m.cx", "m.cy"),
  cellType = "cellType",
  regionName = "domain",
  cores = nCores
)
```

## Region - cell type enrichment heatmap

We can try to interpret which spatial orderings the regions are quantifying using the `regionMap` function. This plots the frequency of each cell type in a region relative to what you would expect by chance.

```{r, fig.height=5, fig.width=5}
# Visualise the enrichment of each cell type in each region
regionMap(cells, cellType = "cellType", region = "domain", limit = c(0.2, 5))+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```


## Visualise regions

We can quickly examine the spatial arrangement of the spatial domains using `ggplot`.


```{r}
# Extract cell information and filter to specific image.
df <- colData(cells) |>
  as.data.frame() |>
  filter(imageID == "Point2206_pt1116_31620")
 #filter(imageID == "Point2203_pt1072_31606")

# Colour cells by their region.
ggplot(df, aes(x = m.cx, y = m.cy, colour = domain)) +
  geom_point()
```


While much slower, we have also implemented a function for overlaying the region information as a hatching pattern so that the information can be viewed simultaneously with the cell type calls.

```{r eval = FALSE}
# Use hatching to visualise regions and cell types.
hatchingPlot(
  cells,
  useImages = "Point2206_pt1116_31620",
  cellType = "cellType",
  region = "domain",
  spatialCoords = c("m.cx", "m.cy")
)
```


<!-- This plot is a ggplot object and so the scale can be modified with `scale_region_manual`.  -->

<!-- ```{r} -->
<!-- # Use hatching to visualise regions and cell types. -->
<!-- # Relabel the hatching of the regions. -->
<!-- hatchingPlot( -->
<!--   cells, -->
<!--   useImages = "Point2206_pt1116_31620", -->
<!--   cellType = "cellType", -->
<!--   spatialCoords = c("m.cx", "m.cy"), -->
<!--   window = "square", -->
<!--   nbp = 300, -->
<!--   line.spacing = 41 -->
<!-- ) + -->

<!--   scale_region_manual(values = c( -->
<!--     region_1 = 2, -->
<!--     region_2 = 1, -->
<!--     region_3 = 5, -->
<!--     region_4 = 4, -->
<!--     region_5 = 3 -->
<!--   )) + -->

<!--   guides(colour = guide_legend(ncol = 2)) -->
<!-- ``` -->

## Test for association with progression

If needed, we can again quickly use the `colTest` function to test for associations between the proportions of the cells in each domain and progression status using either Wilcoxon rank sum tests or t-tests. 


```{r}
# Test if the proportion of each region is associated
# with progression status.
testRegion <- colTest(
  cells[, cellsToUse],
  feature = "domain",
  condition = "Status"
)

testRegion
```

# Are there any cell type associations with progression that are specific to each domain?


```{r}
cells |>
  filter(cellsToUse) |>
  filter(domain == "region_1") |>
  colTest(feature = "cellType", condition = "Status", type = "wilcox")

cells |>
  filter(cellsToUse) |>
  filter(domain == "region_2") |>
  colTest(feature = "cellType", condition = "Status", type = "wilcox")

cells |>
  filter(cellsToUse) |>
  filter(domain == "region_3") |>
  colTest(feature = "cellType", condition = "Status", type = "wilcox")

cells |>
  filter(cellsToUse) |>
  filter(domain == "region_4") |>
  colTest(feature = "cellType", condition = "Status", type = "wilcox")




pval = NULL

propD1 <- getProp(cells[,cells$domain=="region_1"])
propD2 <- getProp(cells[,cells$domain=="region_2"])
propD3 <- getProp(cells[,cells$domain=="region_3"])
propD4 <- getProp(cells[,cells$domain=="region_4"])



for(ct in unique(cells$cellType)){
  
  df <- data.frame(D1 = propD1[rownames(prop),ct], D2 = propD2[rownames(prop),ct], D3 = propD3[rownames(prop),ct], D4 = propD4[rownames(prop),ct], Status = as.character(clinical[rownames(prop), "Status"]), imageID = rownames(prop))
 df_long <- tidyr::pivot_longer(
  df,
  cols = c("D1", "D2", "D3", "D4"),
  names_to = "Domain",
  values_to = "Proportion"
)
  
 model_full <- lmer(sqrt(Proportion) ~ Domain*Status + (1 | imageID), data = df_long)
  model_add <- lmer(sqrt(Proportion) ~ Domain+Status + (1 | imageID), data = df_long)
  an <- anova(model_full, model_add)
  pval[ct] <- an$`Pr(>Chisq)`[2]
}

sort(pval)

ct <- "T_cell_CD8"

  df <- data.frame(D1 = propD1[rownames(prop),ct], D2 = propD2[rownames(prop),ct], D3 = propD3[rownames(prop),ct],D4 = propD4[rownames(prop),ct], Status = as.character(clinical[rownames(prop), "Status"]), imageID = rownames(prop))
 df_long <- tidyr::pivot_longer(
  df,
  cols = c("D1", "D2", "D3", "D4"),
  names_to = "Domain",
  values_to = "Proportion"
)

model <- lmer(sqrt(Proportion) ~ Domain*Status + (1 | imageID), data = df_long)
new_data <- expand.grid(
  Domain = unique(df_long$Domain),
  Status = unique(df_long$Status)
)
new_data$Predicted <- predict(model, newdata = new_data, re.form = NA)

library(ggplot2)

ggplot(df_long, aes(x = Domain, y = sqrt(Proportion), colour = Status)) +
  geom_boxplot(position = position_dodge(0.75)) +
  geom_line(data = new_data, aes(x = Domain, y = Predicted, group = Status), 
            , size = 1.2) +
  geom_point(data = new_data, aes(x = Domain, y = Predicted), 
            , size = 2)


# cells |>
#   filter(cellsToUse) |>
#   filter(domain == "region_4") |>
#   colTest(feature = "cellType", condition = "Status")

# cells |>
#   filter(cellsToUse) |>
#   filter(region == "region_5") |>
#   colTest(feature = "cellType", condition = "Status")  
```


# Are the cell type niches associated with progression?

```{r}
set.seed(51773)

# Cluster cells into spatial regions with similar composition.
cellsNiche <- lisaClust(
  cells,#[, cellsToUse],
  k = 50,
  r = 50,
  sigma = 20,
  spatialCoords = c("m.cx", "m.cy"),
  cellType = "cellType",
  regionName = "niche",
  cores = nCores
)
```



```{r}
# Test if the proportion of each region is associated
# with progression status.
testNiche <- colTest(
  cellsNiche[, cellsToUse],
  feature = "niche",
  condition = "Status"#,
  #type = "wilcox"
)

testNiche
```

```{r}
sort(table(cellsNiche[,cellsNiche$niche=="region_49"]$cellType))
```


```{r, fig.height=5, fig.width=5}
# Visualise the enrichment of each cell type in each region
regionMap(cells, cellType = "cellType", region = "niche", limit = c(0.2, 10))+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```



```{r}
tab <- chisq.test(table(cellsNiche$cellType, cellsNiche$niche))$res

use = rownames(testNiche)[1:10]

tab["T_cell_CD8",use]

sort(tab[,"region_49"])

```



# What if we hadn't clustered down to CD8 T cells?


```{r}
# Can we use mutate instead?

cells$cellTypeMergeTcells <- cells |>
  colData() |>
  as.data.frame() |>
  mutate(cellTypeMergeTcells = factor(case_when(
      cellType == "T_cell_CD8" ~ "T_cell",
      cellType == "T_cell_CD4" ~ "T_cell",
      # cellType == "CK_low_tumour" ~ "Tumour",
      # cellType == "Luminal" ~ "Tumour",
      # cellType == "Basal" ~ "Tumour",
      TRUE ~ cellType
  ))) |> 
  pull(cellTypeMergeTcells) 
  
```





# SpatioMark

```{r}

cells <- getDistances(cells,
  cellType = "cellTypeMergeTcells",
  spatialCoords = c("m.cx", "m.cy"),
  redDimName = "distancesTcells"
)

cells <- getAbundances(cells,
  r = 50,
  cellType = "cellTypeMergeTcells",
  spatialCoords = c("m.cx", "m.cy"),
  redDimName = "abundancesTcells",
)

stateChangesTcells <- calcStateChanges(
  cells,
  assay = "norm",
  cellType = "cellTypeMergeTcells",
  type = "distancesTcells",
  minCells = 5)


stateMatTcells <- prepMatrix(stateChangesTcells, replaceVal = NA, column = "coef")

stateMatTcells[stateMatTcells==Inf] <- NA
stateMatTcells <- stateMatTcells[,colMeans(is.na(stateMatTcells[rownames(prop),]))<0.4]


stateResultsTcells <- colTest(stateMatTcells[rownames(prop), ], droplevels(clinical[rownames(prop), "Status"]))

stateResultsTcells

stateResultsTcells[grep("CD8", stateResultsTcells$cluster),]


stateResultsTcells[grep("T_cell__Tumour__CD8", stateResultsTcells$cluster),]

boxplot(stateMatTcells[rownames(prop), "T_cell__Tumour__CD8"]~ droplevels(clinical[rownames(prop), "Status"]))
abline(h = 0)

```



```{r}

use <- cellsToUse & cells$cellTypeMergeTcells=="T_cell"

x <- reducedDim(cells, "distancesTcells")[use,"Tumour"]

y <- assay(cells,"norm")["CD8",use]

plot(x,y)

```







```{r}

data.frame(colData(cells),reducedDim(cells, "abundancesTcells"), t(assay(cells,  "norm")))|>
  
  filter(cellTypeMergeTcells %in% "T_cell", cellsToUse, !is.na(Tumour)) |>
  mutate(bin = factor(cut(Tumour,c(0,2,4,6,8,10,100),right = FALSE)))|>
  group_by(imageID,bin,Status) |>
  summarise(gene = mean(CD8)) |>
  #mutate(gene = CD8) |> ungroup()|>
  ggplot(aes(x = bin, y = gene, fill = Status)) + geom_boxplot(alpha = 0.5)  + 
    geom_jitter(aes(color = Status), 
              position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.9), 
              size = 2, alpha = 0.7) + geom_smooth(aes(as.numeric(bin), gene, colour = Status),method = "lm", se = FALSE)


data.frame(colData(cells),reducedDim(cells, "distancesTcells"), t(assay(cells, "norm"))) |>
  
  filter(cellTypeMergeTcells %in% "T_cell", cellsToUse, !is.na(Tumour)) |>
  mutate(bin = factor(cut(Tumour,c(0,50,100,150,200,1000),right = FALSE))) |>
  filter(!is.na(bin))|>
  group_by(imageID,bin , Status) |>
  summarise(gene = mean(CD8)) |>
  ggplot(aes(x = bin, y = gene, fill = Status)) + geom_boxplot(alpha = 0.5) + 
    geom_jitter(aes(color = Status), 
              position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.9), 
              size = 2, alpha = 0.7) + geom_smooth(aes(as.numeric(bin), gene, colour = Status),method = "lm", se = FALSE)

```

```{r}

data.frame(colData(cells),reducedDim(cells, "distancesTcells"), t(assay(cells, "norm"))) |>
  
  filter(cellTypeMergeTcells %in% "T_cell", cellsToUse, !is.na(Tumour)) |>
  mutate(bin = factor(cut(Tumour,
                          #seq(0,200,25),
                          c(0,50,1000),
                          #c(0,50,100,150,200,1000),
                          right = FALSE))) |>
  filter(!is.na(bin))|>
  group_by(bin , Status) |>
  summarise(gene = (CD8)) |>
  ggplot(aes(x = bin, y = gene, fill = Status)) + geom_violin(alpha = 0.5) + 
    geom_jitter(aes(color = Status), 
              position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.9), 
              size = 2, alpha = 0.7) + geom_smooth(aes(as.numeric(bin), gene, colour = Status),method = "lm", se = FALSE) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```


```{r}
data.frame(colData(cells),reducedDim(cells, "distancesTcells"), t(assay(cells, "norm"))) |>
  
  filter(cellTypeMergeTcells %in% "T_cell", cellsToUse, !is.na(Tumour)) |>
  
  ggplot(aes(pmin(Tumour,200), CD8, colour = Status)) + geom_point() + geom_smooth()
```




```{r}
p <- plotStateChanges(
  cells = cells,
  type = "distancesTcells",
  image = "Point2312_pt1064_20700",
  from = "T_cell",
  to = "Tumour",
  marker = "CD8",
  spatialCoords = c("m.cx", "m.cy"),
  assay = "norm",
  cellType = "cellTypeMergeTcells",
  size = 1,
  shape = 19,
  interactive = FALSE,
  plotModelFit = TRUE,
  method = "lm")

p
```




# Gene in cell in region

```{r}

data <- data.frame(colData(cells),t(assay(cells,  "norm")))|>
  filter(imageID %in% rownames(prop), cellTypeMergeTcells=="T_cell") |>
  group_by(imageID, domain, Status) |>
  summarise(gene = mean(CD8))

test = NULL
for(i in unique(data$domain)){
test[[i]] <- t.test(gene~Status, data[data$domain==i,])
} 

data.frame(colData(cells),t(assay(cells,  "norm")))|>
  filter(imageID %in% rownames(prop), cellTypeMergeTcells=="T_cell") |>
  group_by(imageID, domain, Status) |>
  summarise(gene = mean(CD8)) |>
  ggplot(aes(y=gene,x=domain, colour = Status))+
  geom_boxplot()
  
test

cells$typeRegion <- paste(cells$cellTypeMergeTcells, cells$domain, sep = "__")

data <- scFeatures(assay(cells, "norm"), 
                   feature_types = c("gene_mean_celltype"),
                   sample = cells$imageID,
                   celltype = cells$typeRegion)

testTypeRegion <- colTest(data[["gene_mean_celltype"]][rownames(prop),], as.character(clinical[rownames(prop), "Status"]))
testTypeRegion
testTypeRegion[grep("T_cell",rownames(testTypeRegion)),]

boxplot(data[["gene_mean_celltype"]][rownames(prop),"T_cell__region_1--CD8"]~as.character(clinical[rownames(prop), "Status"]))


```




<!-- # ClassifyR: Classification -->

<!-- Our ClassifyR package, [https://github.com/SydneyBioX/ClassifyR](https://github.com/SydneyBioX/ClassifyR), formalises a convenient framework for evaluating classification in R. We provide functionality to easily include four key modelling stages; Data transformation, feature selection, classifier training and prediction; into a cross-validation loop. Here we use the `crossValidate` function to perform 100 repeats of 5-fold cross-validation to evaluate the performance of an elastic net model applied to three quantification of our MIBI-TOF data; cell type proportions, average mean of each cell type and region proportions. -->





<!-- ```{r message=FALSE, warning=FALSE} -->
<!-- # Create list to store data.frames -->
<!-- data <- list() -->

<!-- # Add proportions of each cell type in each image -->
<!-- data[["props"]] <- getProp(cells, "clusters") -->

<!-- # Add pair-wise associations -->
<!-- data[["dist"]] <- getPairwise( -->
<!--   cells, -->
<!--   spatialCoords = c("m.cx", "m.cy"), -->
<!--   cellType = "clusters", -->
<!--   Rs = c(20, 50, 100), -->
<!--   sigma = 50, -->
<!--   cores = nCores -->
<!-- ) -->
<!-- data[["dist"]] <- as.data.frame(data[["dist"]]) -->


<!-- # Add proportions of each region in each image -->
<!-- # to the list of dataframes. -->
<!-- data[["regions"]] <- getProp(cells, "region") -->

<!-- # Subset data images with progression status and NA clinical variables. -->
<!-- measurements <- lapply(data, function(x) x[imagesToUse, ]) -->

<!-- # Set seed -->
<!-- set.seed(51773) -->

<!-- # Perform cross-validation of an elastic net model -->
<!-- # with 100 repeats of 5-fold cross-validation. -->
<!-- cv <- crossValidate( -->
<!--   measurements = measurements, -->
<!--   outcome = clinical[imagesToUse, "Status"], -->
<!--   classifier = "GLM", -->
<!--   nFolds = 5, -->
<!--   nRepeats = 100, -->
<!--   nCores = nCores -->
<!-- ) -->
<!-- ``` -->





<!-- ## Visualise cross-validated prediction performance -->

<!-- Here we use the `performancePlot` function to assess the AUC from each repeat of the 5-fold cross-validation. We see that the lisaClust regions appear to capture information which is predictive of progression status of the patients. -->

<!-- ```{r} -->
<!-- # Calculate AUC for each cross-validation repeat and plot. -->
<!-- performancePlot( -->
<!--   cv, -->
<!--   metric = "AUC", -->
<!--   characteristicsList = list(x = "Assay Name") -->
<!-- ) -->
<!-- ``` -->


<!-- # Summary -->

<!-- Here we have used a pipeline of our spatial analysis R packages to demonstrate an easy way to segment, cluster, normalise, quantify and classify high dimensional in situ cytometry data all within R. -->



<!-- ```{r} -->

<!-- cor_between_channels <- function(img) { -->
<!--   channels <- dimnames(img)[[3]] -->
<!--   corr <- NULL -->

<!--   reshaped <- apply(img, 3, as.vector) -->

<!--   for (i in channels) { -->
<!--     for (j in channels) { -->
<!--       # Flatten each colour channel into a vector -->
<!--       v1 <- as.vector(img[,,i]) -->
<!--       v2 <- as.vector(img[,,j]) -->

<!--       relationship <- paste(i,j,sep = "__") -->
<!--       corr[relationship] <- cor(v1, v2) -->
<!--           } -->
<!--   } -->

<!--   return(corr) -->
<!-- } -->


<!-- # Apply to all images -->
<!-- cor_list <- lapply(images[1:2], cor_between_channels) -->




<!-- ``` -->



<!-- ```{r} -->
<!-- make_channel_pairs <- function(channel_names) { -->
<!--   combos <- combn(channel_names, 2, simplify = FALSE) -->
<!--   named_list <- setNames( -->
<!--     lapply(combos, identity), -->
<!--     sapply(combos, function(x) paste(x, collapse = "__")) -->
<!--   ) -->
<!--   return(named_list) -->
<!-- } -->

<!-- channelPairs <- make_channel_pairs(dimnames(images[[1]])[[3]]) -->

<!-- spatstat.explore::dendensity(img[,,1]) -->

<!-- function(img, pairs){ -->
<!--   use <- sample(ncol(img)*nrow(img), 1000) -->
<!--  corr <- lapply(pairs, function(x){ -->
<!--    cor(as.vector(img[,,x[1]])[use], as.vector(img[,,x[2]])[use]) -->
<!--  }) -->
<!-- } -->

<!-- disc <- makeBrush(21, shape='disc') -->
<!-- smoothImages <- BiocParallel::bplapply(images, function(x){ -->
<!--   apply(x,3,function(img){ -->
<!--     filter2(img, disc) -->
<!--   }) -->
<!-- }, BPPARAM = BPPARAM) -->

<!-- correlations <- lapply(images, function(img){ -->
<!-- unlist(lapply(channelPairs, function(x){ -->
<!--   cor(as.vector(img[,,x[1]]), as.vector(img[,,x[2]]), use = "complete") -->
<!-- }))}) -->

<!-- corr <- do.call("rbind", correlations) -->
<!-- tests <- apply(corr[rownames(prop),], 2, function(x){ -->
<!--   t.test(x~clinical[rownames(prop), "Status"])$stat -->
<!-- }) -->


<!-- CD8_ER <- lapply(images[rownames(prop)], function(img){ -->
<!--   disc <- makeBrush(51, shape='disc') -->
<!--   # CD8 <- gblur((img[,,"CD8"]), 5) -->
<!--   # ER <- gblur((img[,,"ECAD"]), 5) -->
<!--  CD8 <- filter2((img[,,"CD8"]), disc) -->
<!--  ECAD <- filter2((img[,,"ECAD"]), disc) -->


<!-- #   CD8 <- imager::correlate(imager::as.cimg(as.matrix(img[,,"CD8"])),imager::as.cimg(disc)) -->
<!-- #   CD8 <- as.matrix(CD8) -->
<!-- #  -->
<!-- # #  ER <- imager::correlate(imager::as.cimg(as.matrix(img[,,"ER"])),imager::as.cimg(disc)) -->
<!-- # #  ER <- as.matrix(ER) -->
<!-- #  -->
<!-- #   ECAD <- imager::correlate(imager::as.cimg(as.matrix(img[,,"ECAD"])),imager::as.cimg(disc)) -->
<!-- #   ECAD <- as.matrix(ECAD) -->

<!--   #corr <- cor(as.vector(CD8), as.vector(ECAD), use = "complete") -->
<!--   #corr -->
<!--   compute_top_right_proportions_fast(cbind(as.vector(CD8), as.vector(ECAD)), 0.33)[1,2] -->

<!-- }) -->

<!-- CD8_ER <- unlist(CD8_ER) -->


<!-- boxplot(CD8_ER[rownames(prop)]~clinical[rownames(prop), "Status"]) -->

<!-- t.test(CD8_ER[rownames(prop)]~clinical[rownames(prop), "Status"]) -->

<!-- ``` -->
<!-- ```{r} -->



<!-- compute_top_right_proportions_fast <- function(mat, threshold = 0.5) { -->
<!--   # Min-max scale each column -->
<!-- trim_99 <- function(x) { -->
<!-- q99 <- quantile(x, 0.99, na.rm = TRUE) -->
<!-- x[x > q99] <- q99 -->
<!--  x -->
<!-- } -->
<!--  mat <- apply(mat, 2, trim_99) -->


<!--   scaled <- sweep(mat, 2, apply(mat, 2, min), "-") -->
<!--   scaled <- sweep(scaled, 2, apply(mat, 2, max) - apply(mat, 2, min), "/") -->

<!--   # Logical matrix: TRUE if value > threshold -->
<!--   mask <- scaled > threshold -->

<!--   # Compute pairwise proportions using cross-product -->
<!--   proportions <- (t(mask) %*% mask) / nrow(mat) -->

<!--   # Set diagonal to 0 -->
<!--   diag(proportions) <- 0 -->

<!--   # Add names if available -->
<!--   if (!is.null(colnames(mat))) { -->
<!--     colnames(proportions) <- colnames(mat) -->
<!--     rownames(proportions) <- colnames(mat) -->
<!--   } -->

<!--   return(proportions) -->
<!-- } -->






<!-- compute_colour_correlations_fast <- function(image_array, patch_size = 8) { -->
<!--   h <- dim(image_array)[1] -->
<!--   w <- dim(image_array)[2] -->
<!--   ch <- dim(image_array)[3] -->

<!--   # Crop image to fit patch size -->
<!--   h_crop <- floor(h / patch_size) * patch_size -->
<!--   w_crop <- floor(w / patch_size) * patch_size -->
<!--   image_array <- image_array[1:h_crop, 1:w_crop, ] -->

<!--   # Reshape into patches -->
<!--   patches <- array(image_array, dim = c(patch_size, h_crop / patch_size, patch_size, w_crop / patch_size, ch)) -->
<!--   patches <- aperm(patches, c(2, 4, 5, 1, 3))  # [patch_y, patch_x, channel, patch_h, patch_w] -->

<!--   # Compute mean intensity per patch per channel -->
<!--   patch_means <- apply(patches, c(1, 2, 3), mean)  # [patch_y, patch_x, channel] -->
<!--   patch_means <- matrix(aperm(patch_means, c(1, 2, 3)), ncol = ch)  # [num_patches, channels] -->

<!--   # Correlation matrix -->
<!--  # cor(patch_means) -->

<!--   # Continuous mutual information -->
<!--   compute_top_right_proportions_fast(patch_means, threshold = 0.1) -->

<!-- } -->


<!-- corrs <- lapply(images, function(img){ -->
<!--   compute_colour_correlations_fast(img, patch_size = 50) -->
<!-- }) -->

<!-- corArray <- abind::abind(corrs, along = 3) -->

<!-- corTest <- apply(corArray[,,rownames(prop)], c(1,2), function(x){ -->
<!--   tryCatch({t.test(x~clinical[rownames(prop), "Status"])$statistic}, error = function(e)NA) -->
<!-- }) -->

<!-- colnames(corTest) <- rownames(corTest) <- dimnames(images[[1]])[[3]] -->


<!-- # Assume `mat` is your matrix with row and column names -->
<!-- vec <- as.vector(corTest) -->
<!-- names(vec) <- outer(rownames(corTest), colnames(corTest), paste, sep = "__") -->
<!-- names(vec) <- as.vector(names(vec)) -->


<!-- corArray2 <- corArray -->
<!-- colnames(corArray2) <- rownames(corArray2) <- dimnames(images[[1]])[[3]] -->

<!-- boxplot(corArray2["ER","CD8",rownames(prop)]~clinical[rownames(prop), "Status"]) -->
<!-- t.test(corArray2["ECAD","CD8",rownames(prop)]~clinical[rownames(prop), "Status"]) -->


<!-- boxplot(corArray2["FOXP3","IDO1",rownames(prop)]~clinical[rownames(prop), "Status"]) -->


<!-- ``` -->


<!-- ```{r} -->
<!-- # Set patch size -->
<!-- patch_height <- 16 -->
<!-- patch_width <- 16 -->

<!-- # Get dimensions -->
<!-- img_dims <- dim(img) -->
<!-- h <- img_dims[1] -->
<!-- w <- img_dims[2] -->
<!-- channels <- img_dims[3] -->

<!-- # Function to compute patch means -->
<!-- get_patch_means <- function(img, ph, pw) { -->
<!--   h_patches <- floor(h / ph) -->
<!--   w_patches <- floor(w / pw) -->

<!--   # Initialize output: patch x channel -->
<!--   patch_means <- array(NA, dim = c(h_patches, w_patches, channels)) -->

<!--   for (ch in 1:channels) { -->
<!--     for (i in 1:h_patches) { -->
<!--       for (j in 1:w_patches) { -->
<!--         patch <- img[((i - 1) * ph + 1):(i * ph), ((j - 1) * pw + 1):(j * pw), ch] -->
<!--         patch_means[i, j, ch] <- mean(patch) -->
<!--       } -->
<!--     } -->
<!--   } -->
<!--   return(patch_means) -->
<!-- } -->

<!-- # Compute means -->
<!-- means <- get_patch_means(img, patch_height, patch_width) -->


<!-- ``` -->




# sessionInfo

```{r}
sessionInfo()
```