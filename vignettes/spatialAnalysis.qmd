---
title: "Making Space Count: Strategies for Analysing Spatial Omics Data"
params:
  test: FALSE
author:
- name: Shreya Rao
  affiliation:  
  - &WIMR Westmead Institute for Medical Research, Australia
  - School of Mathematics and Statistics, University of Sydney, Australia
  - Sydney Precision Data Science Centre, University of Sydney, Australia
- name: Ellis Patrick
  affiliation:
  - &WIMR Westmead Institute for Medical Research, Australia
  - School of Mathematics and Statistics, University of Sydney, Australia
  - Sydney Precision Data Science Centre, University of Sydney, Australia
date: 24 June 2025
vignette: >
  %\VignetteIndexEntry{"Making Space Count: Strategies for Analysung Spatial Omics Data"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  BiocStyle::html_document
---


```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(BiocStyle)
```

# Version Info

<p>
**R version**: `r R.version.string`
<br />
**Bioconductor version**: `r BiocManager::version()`
<br />

# Introduction


# Loading R packages

```{r load libraries, echo=FALSE, results="hide", warning=FALSE}
suppressPackageStartupMessages({
  library(cytomapper)
  library(dplyr)
  library(ggplot2)
  library(simpleSeg)
  library(FuseSOM)
  library(ggpubr)
  library(scater)
  library(spicyR)
  library(ClassifyR)
  library(lisaClust)
  library(tidySpatialExperiment)
  library(treekoR)
  library(Statial)
  library(scFeatures)
})
```

```{r, eval=FALSE}
library(cytomapper)
library(dplyr)
library(ggplot2)
library(simpleSeg)
library(FuseSOM)
library(ggpubr)
library(scater)
library(spicyR)
library(ClassifyR)
library(lisaClust)
library(tidySpatialExperiment)
library(treekoR)
library(Statial)
library(scFeatures)
```


# Global paramaters

The code below automatically detects the number of available CPU cores on your system and configures parallel processing accordingly. If you're on a Windows machine, it uses a socket-based backend (SnowParam), while Unix-based systems (macOS/Linux) use a fork-based backend (MulticoreParam).

If only one core is available or parallel execution is disabled, it defaults to serial processing. We recommend using at least 2 cores as parts of the workflow can be computationally intensive. If you do not wish to use multiple cores, you can set `use_mc = FALSE`.

```{r set parameters}
# set parameters
set.seed(51773)

# whether to use multiple cores (recommended)
use_mc = TRUE
is_windows = .Platform$OS.type == "windows"

if (use_mc) {
  nCores = max(floor(parallel::detectCores() / 2), 1)
  
  if (nCores == 1) {
    BPPARAM = BiocParallel::SerialParam()
  } else if (is_windows) {
    BPPARAM = BiocParallel::SnowParam(workers = nCores, type = "SOCK")
  } else {
    BPPARAM = BiocParallel::MulticoreParam(workers = nCores)
  }
} else {
  BPPARAM = BiocParallel::SerialParam()
}

theme_set(theme_classic())
```

# Context

In this workshop, we will analyse some MIBI-TOF data [(Risom et al, 2022)](https://www.sciencedirect.com/science/article/pii/S0092867421014860?via%3Dihub#!) profiling the spatial landscape of ductal carcinoma in situ (DCIS), which is a pre-invasive lesion that is thought to be a precursor to invasive breast cancer (IBC). The key conclusion of this manuscript (amongst others) is that spatial information about cells can be used to predict disease progression in patients. 


# Read in images

The images are stored in the `images` folder within the `data` folder in the form of single-channel TIFF images. In single-channel images, each pixel represents intensity values for a single marker. Here, we use the `loadImages` function from the `cytomapper` package to load all the TIFF images into a `CytoImageList` object and store the images as h5 file on-disk.


```{r load images}
pathToImages <- system.file("extdata/images", package = "spicyWorkflow")

# approx. runtime: 40 secs
images <- cytomapper::loadImages(
  pathToImages,
  single_channel = TRUE, # one image per channel
  on_disk = TRUE, # on-disk loading to save RAM
  h5FilesPath = HDF5Array::getHDF5DumpDir(),
  BPPARAM = BPPARAM,
  as.is = TRUE
)

# free unused memory
gc()
```



# Load the clinical data

To link image features with disease progression, we need to import the clinical information that associates each image identifier with its corresponding progression status and patient metadata. We will do this here, making sure that the `imageID` values are correctly matched.

## Read the clinical data

```{r load clincal data}
# read the clinical data CSV file 
clinical <- read.csv(
  system.file(
    "extdata/1-s2.0-S0092867421014860-mmc1.csv",
    package = "spicyWorkflow"
  )
)

# create a new 'imageID' column by concatenating relevant identifiers
clinical <- clinical |>
  mutate(imageID = paste0(
    "Point", PointNumber, "_pt", Patient_ID, "_", TMAD_Patient
  ))

# find rows where Tissue_Type is "normal" and append "_Normal" to their imageID
image_idx <- grep("normal", clinical$Tissue_Type)
clinical$imageID[image_idx] <- paste0(clinical$imageID[image_idx], "_Normal")

# clinical variables of interest
clinicalVariables <- c(
  "imageID", "Patient_ID", "Status", "Age", "SUBTYPE", "PAM50", "Treatment",
  "DCIS_grade", "Necrosis"
)

clinical$Status <- factor(clinical$Status)
rownames(clinical) <- clinical$imageID
```


## Put the clinical data into the colData of CytoImageList

We can then store the clinical information in the `mcols` slot of the `CytoImageList` object.

```{r add clinical data}
# Add the clinical data to mcols of images
mcols(images) <- clinical[names(images), clinicalVariables]
```

# Where are the cells in the images?

## Run simpleSeg

Next, we can perform our segmentation. The [simpleSeg](https://www.bioconductor.org/packages/release/bioc/html/simpleSeg.html) package on Bioconductor provides functionality for user friendly, watershed based segmentation on multiplexed cellular images based on the intensity of user-specified marker channels. The main function, `simpleSeg`, can be used to perform a simple cell segmentation process that traces out the nuclei using a specified channel.

```{r segment}
# Generate segmentation masks
# approx. runtime: 10.3 mins
masks <- simpleSeg(
  images,
  nucleus = c("HH3"), # trace out nuclei using the HH3 marker
  cellBody = "dilate", # use dilation strategy of segmentation
  transform = c("tissueMask","sqrt"), # remove background noise outside of sample area and perform sqrt transform
  sizeSelection = 20, # only cells > 20 pixels will be used
  discSize = 5, # dilate out from nucleus by 5 pixels
  cores = nCores
)
```


## Visualise separation

We can examine the performance of the cell segmentation using the `display` and `colorLabels` functions from the `EBImage` package. 

```{r visualise segmentation}
# Visualise segmentation performance one way.
EBImage::display(colorLabels(masks[[1]]))
```

## Visualise outlines

To assess segmentation accuracy, we can overlay the nuclei masks onto the corresponding nuclear intensity channel with the `plotPixels` function from the `cytomapper` package. Ideally, the mask outlines (shown in white in the image below) should closely align with the boundaries of the nuclear signal (visualised in blue), indicating that the segmentation correctly captures the extent of each nucleus. 

```{r}
# Visualise segmentation performance another way.
cytomapper::plotPixels(
  image = images[1],
  mask = masks[1],
  img_id = "imageID",
  colour_by = c("PanKRT", "HH3", "CD3", "CD20"),
  display = "single",
  colour = list(
    HH3 = c("black", "blue"),
    CD3 = c("black", "green"),
    CD20 = c("black", "red"),
    PanKRT = c("black", "yellow")
  ),
  bcg = list(
    HH3 = c(0, 1, 1.5),
    CD3 = c(0, 1, 3),
    CD20 = c(0, 1, 3),
    PanKRT = c(0, 1, 1.5)
  ),
  legend = NULL
)
```

In the image above, we can see that we've done relatively well at capturing the HH3 signal, but perhaps not such a good job at capturing the PanKRT signal, which largely lies outside our segmented outlines. To remedy this, we can increase `discSize` to capture more of the cell body; however, we need avoid capturing signal from neighbouring cells. Balancing the dilation size to capture the full cell body while minimising lateral spillover is therefore crucial. 

# Summarise cell features

In order to characterise the phenotypes of each of the segmented cells, `measureObjects` from `cytomapper` will calculate the average intensity of each channel within each cell as well as a few morphological features. The channel intensities will be stored in the `counts assay` in a `SpatialExperiment`. Information on the spatial location of each cell is stored in `colData` in the `m.cx` and `m.cy` columns. In addition to this, it will propagate the information we have store in the `mcols` of our `CytoImageList` in the `colData` of the resulting `SpatialExperiment`. 

```{r}
# Summarise the expression of each marker in each cell
# approx. runtime: 5 mins
cells <- cytomapper::measureObjects(
  masks,
  images,
  img_id = "imageID",
  return_as = "sce",
  feature_types = c("basic", "moment"),
  BPPARAM = BPPARAM
)

cells <- cells |> filter(!imageID %in% c('Point6103_pt1008_20624', 'Point6203_pt1107_31568', 'Point6206_pt1197_31571', 'Point6201_pt1027_20597'))
```



# How can we make marker quantification comparable across images?

Variability in marker intensity across images is a common challenge in spatial imaging, often driven by technical factors like staining efficiency, imaging conditions, or sample preparation. Because raw intensities aren’t always directly comparable across or within images, quality control is an essential next step after segmentation. 

Below, we extract marker intensities from the `counts` assay and take a closer look at the cytokeratin 7 (`CK7`) marker, which is often used as a diagnostic marker in breast cancer.

```{r, fig.width=5, fig.height=5}
# Extract marker data and bind with information about images
df <- as.data.frame(cbind(colData(cells), t(assay(cells, "counts"))))

# Plots densities of CK7 for each image.
ggplot(df, aes(x = CK7, colour = imageID)) +
  geom_density() +
  theme(legend.position = "none")
```

We can see that CK7 intensity is highly skewed, which makes it difficult to distinguish CK7+ cells from CK7- cells. Ideally, we would want to see a bimodal distribution of marker intensity, with one peak corresponding to CK7- cells and the other peak corresponding to CK7+ cells. This clear distinction between marker+ and marker- cells would also ensure that downstream clustering processes can easily distinguish between marker+ and marker- cells. 

Additionally, we would also want to see that our marker+ or marker- cells are consistent across images, so that cells classified as CK7+ positive in one image are also classified as CK7+ in another image. If these peaks are not consistent, it might point to image-level batch effects.

We can transform and normalise our data using the `normalizeCells` function from the `simpleSeg`. Here we have taken the intensities from the `counts` assay, performed an arcsine transform, then for each image trimmed the 99 quantile and min-max scaled to 0-1. This modified data is then stored in the `norm` assay by default. We can see that this normalised data appears more bimodal, not perfectly, but likely to a sufficient degree for clustering.


```{r, fig.width=5, fig.height=5}
# Transform and normalise the marker expression of each cell type.
# Use a  arc-sine transform, then trimmed the 99 quantile and then remove first principal component
cells <- normalizeCells(cells,
  transformation = "asinh",
  method = c("trim99", "minMax", "PC1"),
  assayIn = "counts",
  cores = nCores
)

# Extract normalised marker information.
norm_df <- as.data.frame(cbind(colData(cells), t(assay(cells, "norm"))))


# Plots densities of normalised CK7 for each image.
ggplot(norm_df, aes(x = CK7, colour = imageID)) +
  geom_density() +
  theme(legend.position = "none")
```

::: callout-tip
**Choosing transformation and normalisation methods**

Not all datasets require the same transformation or normalisation strategy. Choosing the right one can depend on both the biological context and the source of technical variability.

-  If our marker intensities show strong tails, applying a transformation (e.g., square root, log, or arcsinh) can help separate low vs high signal populations.

- If we observe inconsistent peaks across images, we could use normalisation techniques such as centering on the mean, scaling by standard deviation, or regression-based adjustments (e.g., removing PC1, removing the highest 1% of values, etc.).

- Are there markers you shouldn’t normalise? Nuclear markers like DNA1, DNA2, or HH3 often serve as internal references and typically aren’t normalised.

:::

# What types of cells are in my images?

Identifying what cell types are present in our images is a key step in many spatial analysis workflows, as it shapes how we analyse tissue composition, measure cell-cell interactions, and track disease mechanisms.  One common approach is to apply unsupervised clustering methods followed by manual annotation of the resulting clusters.


## Use clustering

Clustering groups cells by similarity in their marker expression patterns, helping to identify distinct cell types or states. 

```{r FuseSOM}
# The markers used in the original publication to gate cell types.
useMarkers <- c(
  # Epithelial/tumour markers
  "PanKRT",       # Pan-cytokeratin: general epithelial marker (tumour or normal epithelium)
  "ECAD",         # E-cadherin: adherens junctions, epithelial cell integrity; also seen in myoepithelium
  "CK7",          # Cytokeratin 7: luminal epithelial marker
  "VIM",          # Vimentin: mesenchymal marker; high in fibroblasts, EMT tumour cells, and endothelium

  # Stromal markers
  "FAP",          # Fibroblast activation protein: cancer-associated fibroblasts (CAFs)
  "CD31",         # PECAM1: endothelial cell marker (blood vessels)
  "CK5",          # Cytokeratin 5: basal epithelial and myoepithelial marker
  "SMA",          # Smooth muscle actin: myoepithelial cells and myofibroblasts

  # Immune lineage marker
  "CD45",         # Pan-leukocyte marker: expressed on all immune cells

  # T cells
  "CD4",          # Helper T cells: subset of CD3+ T cells
  "CD3",          # T cell receptor complex: all T cells
  "CD8",          # Cytotoxic T cells: subset of CD3+ T cells

  # B cells
  "CD20",         # B cell marker: mature B cells

  # Myeloid/antigen-presenting cells
  "CD68",         # Macrophage marker: especially tumour-associated macrophages
  "CD14",         # Monocyte marker: also on some dendritic cells
  "CD11c",        # Myeloid dendritic cells: also on monocyte-derived DCs and some macrophages
  "HLADRDPDQ",    # MHC class II: antigen presentation, expressed on DCs, macrophages, B cells

  # Granulocytes and mast cells
  "MPO",          # Myeloperoxidase: neutrophils and granulocytes
  "Tryptase"      # Mast cells: granule content marker, specific for mast cells
)

```

Here, we perform clustering with the `runFuseSOM` function from the [FuseSOM](https://www.bioconductor.org/packages/release/bioc/html/FuseSOM.html) package, using the same subset of markers as the original manuscript for cell type gating. The number of clusters is set to `numClusters = 16`.

```{r}
# Set seed.
set.seed(51773)

cells@metadata <- list()

# Generate SOM and cluster cells into 16 groups.
cells <- runFuseSOM(
  cells,
  markers = useMarkers,
  assay = "norm",
  numClusters = 16
)

cells$cellType <- cells$clusters
```


## Check how many clusters should be used.

We can assess the suitability of our choice of 16 clusters using the `estimateNumCluster` and `optiPlot` functions from the `FuseSOM` package. Here, we focus on the Gap statistic method, though other options like Silhouette and Within Cluster Distance are also available.

::: callout-tip

 - Generally, we're looking for the `k` (number of clusters) before the point of greatest inflection, or the point beyond which increasing `k` results in minimal improvement to clustering quality. 
 
- There can be several options of `k` if there are several points of inflection. The optimal choice depends on the expected number of cell types and the desired level of annotation resolution.

::: callout-tip

As we can be seen below, we chose the second elbow point as the optimal number of clusters.


```{r}
cells <- estimateNumCluster(cells, kSeq = 2:30)
optiPlot(cells, method = "gap")
```

## Attempt to interpret the phenotype of each cluster

We can begin the process of understanding what each of these cell clusters are by using the `plotGroupedHeatmap` function from `scater`. At the least, here we can see we capture all the major immune populations that we expect to see.

```{r}
# Visualise marker expression in each cluster.
scater::plotGroupedHeatmap(
  cells,
  features = useMarkers,
  group = "clusters",
  exprs_values = "norm",
  center = TRUE,
  scale = TRUE,
  zlim = c(-3, 3),
  cluster_rows = FALSE,
  block = "clusters"
)
```

We can then annotate the clusters based on the canonical cell type markers they express.


```{r}
# annotate cell populations

cells$cellType <- cells |>
  colData() |>
  as.data.frame() |>
  mutate(cellType = factor(case_when(
      clusters == "cluster_1" ~ "Tumour",
      clusters == "cluster_2" ~ "T_cell_CD4",
      clusters == "cluster_3" ~ "T_cell_CD8",
      clusters == "cluster_4" ~ "Granulocytes",
      clusters == "cluster_5" ~ "B_cells",
      clusters == "cluster_6" ~ "DC",
      clusters == "cluster_7" ~ "Myoepithilial",
      clusters == "cluster_8" ~ "Monocyte",
      clusters == "cluster_9" ~ "OtherImmune",
      clusters == "cluster_10" ~ "Fibroblast",
      clusters == "cluster_11" ~ "OtherImmune",
      clusters == "cluster_12" ~ "Macrophage",
      clusters == "cluster_13" ~ "Endothelial",
      clusters == "cluster_14" ~ "Mast",
      clusters == "cluster_15" ~ "Endothelial",
      clusters == "cluster_16" ~ "Myoepithilial",
      TRUE ~ clusters
  ))) |> 
  pull(cellType) 
  
```

## Check cluster frequencies

It’s always helpful to examine the number of cells in each cluster, as this provides insight into cluster relevance and stability. Here, we can see that 

```{r}
# Check cluster frequencies.
colData(cells)$cellType |>
  table() |>
  sort()
```


## Plot cell types on an image

We can plot the cell types on an image to view their spatial distribution.

```{r}
reducedDim(cells, "spatialCoords") <- cbind(x = cells$m.cx, y = cells$m.cy)

cells |> 
  #filter(imageID == "Point2203_pt1072_31606") |> 
  filter(imageID == "Point2206_pt1116_31620") |>
  plotReducedDim("spatialCoords", colour_by = "cellType")

```

In the heatmap above, E-cadherin (ECAD) is not significantly highly expressed in any cluster. We can visualise its expression across different cell types, as seen in the plot below. ECAD is typically strongly expressed in tumour epithelial cells, so we would expect to see high ECAD expression in the `Tumour` cell population if the clustering and annotation have been successful.


```{r fig.width = 12, fig.height = 4}

cells |> 
  join_features(features = c("ECAD"), assay = "norm", shape = "wide") |>
  ggplot(aes(x = cellType, y = ECAD)) + geom_boxplot()

```


## Dimension reduction

As our data is stored in a `SingleCellExperiment` object, we can visualise our data in a lower dimension and look for image-level batch effects with a UMAP.

```{r}
set.seed(51773)
# Perform dimension reduction using UMP.
cells <- scater::runUMAP(
  cells,
  subset_row = useMarkers,
  exprs_values = "norm"
)

# Select a subset of images to plot.
someImages <- unique(colData(cells)$imageID)[c(1, 10, 20, 40, 50, 60)]


# UMAP by cell type cluster.
scater::plotReducedDim(
  cells[, colData(cells)$imageID %in% someImages],
  dimred = "UMAP",
  colour_by = "clusters"
)
```


# Are there cell types that are more or less abundant with disease status?

We recommend using a package such as `diffcyt` for testing for changes in abundance of cell types. However, the `colTest` function from the `spicyR` package allows us to quickly test for associations between the proportions of cell types and progression status using either Wilcoxon rank sum tests or t-tests. 

```{r}
# Select cells which belong to individuals with progressor status
# Filter for Luminal B cancer subtype
cellsToUse <- cells$Status %in% c("nonprogressor","progressor") &
  cells$PAM50 == "LumB" & !is.na(cells$PAM50)

# Perform simple wicoxon rank sum tests on the columns of the proportion matrix.
testProp <- colTest(cells[, cellsToUse],
  condition = "Status",
  feature = "cellType"
)

testProp
```

```{r}
# Select images corresponding to individuals with known progressor status
imagesToUse <- rownames(clinical)[clinical[, "Status"] %in% c("nonprogressor", "progressor")]

# Calculate cell type proportions using selected cells
prop <- getProp(cells[, cellsToUse], feature = "cellType")

# Identify the most significant cell type from test results
clusterToUse <- rownames(testProp)[1]

# Visualise the distribution of that cell type across clinical status groups
boxplot(
  prop[imagesToUse, clusterToUse] ~ droplevels(clinical[imagesToUse, "Status"]),
  main = paste("Proportion of", clusterToUse, "by Clinical Status"),
  xlab = "Clinical Status",
  ylab = "Cell Type Proportion",
)

```

We can see that B cells are generally more abundant in progressors compared to non-progressors.

We can also view proportions for a specific cell type of interest, such as CD8 T cells.


```{r}
# Select images corresponding to individuals with known progressor status
imagesToUse <- rownames(clinical)[clinical[, "Status"] %in% c("nonprogressor", "progressor")]

# Calculate cell type proportions using selected cells
prop <- getProp(cells[, cellsToUse], feature = "cellType")

# Visualise the distribution of CD8 T cells across clinical status groups
boxplot(
  prop[imagesToUse, "T_cell_CD8"] ~ droplevels(clinical[imagesToUse, "Status"]),
  main = paste("Proportion of", clusterToUse, "by Clinical Status"),
  xlab = "Clinical Status",
  ylab = "Cell Type Proportion",
)

```

Progressors have a higher proportion of CD8 T cells compared to non-progressors.

# Do spatial relationships between cell types change?

Spatial co-localisation analysis helps uncover whether specific cell types are found near each other more (or less) often than expected by chance. The [spicyR](https://www.bioconductor.org/packages/release/bioc/html/spicyR.html) package can be used to calculate a co-localisation metric. This metric quantifies whether two cell types in an image tend to be closer together (co-localised) or further apart (dispersed) than would be expected by chance. A positive value indicates that two cell types are co-localised, while a negative value suggests they are dispersed. A value around 0 indicates random distribution. 

## CD8 T cells are more localised with tumour cell subset in progressors

We can use the `spicy` function from the `spicyR` package to evaluate all pairwise relationships between cell types. To draw meaningful conclusions from co-localisation patterns, it’s important to carefully choose the proximity radius `r` — the distance that defines when two cells are considered “near” each other. This radius should reflect the biological scale of interaction, such as the typical signaling range or physical cell contact. If the radius is too small, real associations might be missed due to slight spatial variability or measurement noise. On the other hand, if the radius is too large, the analysis may pick up false signals driven by overall regional cell density rather than genuine biological interactions.

```{r}
# Test for changes in pair-wise spatial relationships between cell types.

spicyTest <- spicy(
  cells[, cellsToUse], # Select for progressors and non-progressors only
  condition = "Status", # the clinical outcome of interest
  cellType = "cellType",
  imageID = "imageID",
  spatialCoords = c("m.cx","m.cy"),
  r = 50, # evaluate spatial relationships at 50 pixels
  sigma = 20, # account for tissue inhomogeneity
  cores = nCores
)

topPairs(spicyTest, n = 20)
```

The most significant cell type interaction is ``

::: {.callout-tip title="Choosing parameters for spicy"}
**How do we select an optimal value for `r`?**

-   The choice of `r` will depend on the degree of co-localistion we expect to see and the biological context. Choosing a small value of `r` is optimal for examining local spatial relationships, and larger values of `r` will reveal global spatial relationships.

-   When the degree of localistion is unknown, it is best to choose a range of radii to define the co-localisation statistic to capture both local and global relationships.
:::


We can visualise these tests using `signifPlot` where we observe that cell type pairs appear to become less attractive (or avoid more) in the progression sample.

```{r}
# Visualise which relationships are changing the most.
signifPlot(
  spicyTest,
  breaks = c(-1.5, 3, 0.5)
)
```

## Add in nearest neighbours approach

# Are tumour cells closer to CD8 t cells than other t cells in progressors?

```{r}

set.seed(51773)
# Calculate hierarchy using treekoR
# clusterTree <- treekoR::getClusterTree(t(assay(cells, "norm")[useMarkers[useMarkers!="CD45"],]),
#                             cells$cellType,
#                             hierarchy_method="complete",
#                             hopach_K = 5,
#                             hopach_kmax = 10,
#                             scale = FALSE)
# 
# # Convert treekoR result to a name list of parents and children.
# treekorParents = getParentPhylo(clusterTree)

treekorParents <- list(T_cell = c("T_cell_CD8", "T_cell_CD4"), Immune = c("B_cells", "T_cell_CD8", "T_cell_CD4", "Granulocytes", "OtherImmune", "Mast", "Macrophage", "Monocyte", "DC"))

#treekorParents <- list(T_cell = c("cluster_2", "cluster_3"), Immune = c("cluster_2","cluster_3","cluster_4","cluster_5","cluster_6","cluster_8", "cluster_9","cluster_11", "cluster_13"))



parentDf <- parentCombinations(
  all = as.character(unique(cells$cellType)),
  parentList = treekorParents
)

#cells$cellTypeChar <- as.character(cells$cellType)

kontextualResult <- Kontextual(
  cells = cells[, cellsToUse],
  parentDf = parentDf,
  r = 100,
  cellType = "cellType",
  spatialCoords = c("m.cx","m.cy"),
  cores = nCores
)

```




```{r}

kontextMat <- prepMatrix(kontextualResult)

kontextResults <- colTest(kontextMat[rownames(prop), ], as.character(clinical[rownames(prop), "Status"]))

head(kontextResults)
```


# Are there any broad spatial domains associated with progression?

## Tweak settings a bit

```{r}
set.seed(51773)

# Cluster cells into spatial regions with similar composition.
cells <- lisaClust(
  cells,
  k = 4,
  r = c(20,50,100),
  sigma = 20,
  spatialCoords = c("m.cx", "m.cy"),
  cellType = "cellType",
  regionName = "domain",
  cores = nCores
)
```

## Region - cell type enrichment heatmap

We can try to interpret which spatial orderings the regions are quantifying using the `regionMap` function. This plots the frequency of each cell type in a region relative to what you would expect by chance.

```{r, fig.height=5, fig.width=5}
# Visualise the enrichment of each cell type in each region
regionMap(cells, cellType = "cellType", region = "domain", limit = c(0.2, 5))+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```


## Visualise regions

We can quickly examine the spatial arrangement of the spatial domains using `ggplot`.


```{r}
# Extract cell information and filter to specific image.
df <- colData(cells) |>
  as.data.frame() |>
  filter(imageID == "Point2206_pt1116_31620")
 #filter(imageID == "Point2203_pt1072_31606")

# Colour cells by their region.
ggplot(df, aes(x = m.cx, y = m.cy, colour = domain)) +
  geom_point()
```


While much slower, we have also implemented a function for overlaying the region information as a hatching pattern so that the information can be viewed simultaneously with the cell type calls.

```{r eval = FALSE}
# Use hatching to visualise regions and cell types.
hatchingPlot(
  cells,
  useImages = "Point2206_pt1116_31620",
  cellType = "cellType",
  region = "domain",
  spatialCoords = c("m.cx", "m.cy")
)
```


<!-- This plot is a ggplot object and so the scale can be modified with `scale_region_manual`.  -->

<!-- ```{r} -->
<!-- # Use hatching to visualise regions and cell types. -->
<!-- # Relabel the hatching of the regions. -->
<!-- hatchingPlot( -->
<!--   cells, -->
<!--   useImages = "Point2206_pt1116_31620", -->
<!--   cellType = "cellType", -->
<!--   spatialCoords = c("m.cx", "m.cy"), -->
<!--   window = "square", -->
<!--   nbp = 300, -->
<!--   line.spacing = 41 -->
<!-- ) + -->

<!--   scale_region_manual(values = c( -->
<!--     region_1 = 2, -->
<!--     region_2 = 1, -->
<!--     region_3 = 5, -->
<!--     region_4 = 4, -->
<!--     region_5 = 3 -->
<!--   )) + -->

<!--   guides(colour = guide_legend(ncol = 2)) -->
<!-- ``` -->

## Test for association with progression

If needed, we can again quickly use the `colTest` function to test for associations between the proportions of the cells in each domain and progression status using either Wilcoxon rank sum tests or t-tests. 


```{r}
# Test if the proportion of each region is associated
# with progression status.
testRegion <- colTest(
  cells[, cellsToUse],
  feature = "domain",
  condition = "Status"
)

testRegion
```

# Are there any cell type associations with progression that are specific to each domain?


```{r}
cells |>
  filter(cellsToUse) |>
  filter(domain == "region_1") |>
  colTest(feature = "cellType", condition = "Status", type = "wilcox")

cells |>
  filter(cellsToUse) |>
  filter(domain == "region_2") |>
  colTest(feature = "cellType", condition = "Status", type = "wilcox")

cells |>
  filter(cellsToUse) |>
  filter(domain == "region_3") |>
  colTest(feature = "cellType", condition = "Status", type = "wilcox")

cells |>
  filter(cellsToUse) |>
  filter(domain == "region_4") |>
  colTest(feature = "cellType", condition = "Status", type = "wilcox")




pval = NULL

propD1 <- getProp(cells[,cells$domain=="region_1"])
propD2 <- getProp(cells[,cells$domain=="region_2"])
propD3 <- getProp(cells[,cells$domain=="region_3"])
propD4 <- getProp(cells[,cells$domain=="region_4"])



for(ct in unique(cells$cellType)){
  
  df <- data.frame(D1 = propD1[rownames(prop),ct], D2 = propD2[rownames(prop),ct], D3 = propD3[rownames(prop),ct], D4 = propD4[rownames(prop),ct], Status = as.character(clinical[rownames(prop), "Status"]), imageID = rownames(prop))
 df_long <- tidyr::pivot_longer(
  df,
  cols = c("D1", "D2", "D3", "D4"),
  names_to = "Domain",
  values_to = "Proportion"
)
  
 model_full <- lmer(sqrt(Proportion) ~ Domain*Status + (1 | imageID), data = df_long)
  model_add <- lmer(sqrt(Proportion) ~ Domain+Status + (1 | imageID), data = df_long)
  an <- anova(model_full, model_add)
  pval[ct] <- an$`Pr(>Chisq)`[2]
}

sort(pval)

ct <- "T_cell_CD8"

  df <- data.frame(D1 = propD1[rownames(prop),ct], D2 = propD2[rownames(prop),ct], D3 = propD3[rownames(prop),ct],D4 = propD4[rownames(prop),ct], Status = as.character(clinical[rownames(prop), "Status"]), imageID = rownames(prop))
 df_long <- tidyr::pivot_longer(
  df,
  cols = c("D1", "D2", "D3", "D4"),
  names_to = "Domain",
  values_to = "Proportion"
)

model <- lmer(sqrt(Proportion) ~ Domain*Status + (1 | imageID), data = df_long)
new_data <- expand.grid(
  Domain = unique(df_long$Domain),
  Status = unique(df_long$Status)
)
new_data$Predicted <- predict(model, newdata = new_data, re.form = NA)

library(ggplot2)

ggplot(df_long, aes(x = Domain, y = sqrt(Proportion), colour = Status)) +
  geom_boxplot(position = position_dodge(0.75)) +
  geom_line(data = new_data, aes(x = Domain, y = Predicted, group = Status), 
            , size = 1.2) +
  geom_point(data = new_data, aes(x = Domain, y = Predicted), 
            , size = 2)


# cells |>
#   filter(cellsToUse) |>
#   filter(domain == "region_4") |>
#   colTest(feature = "cellType", condition = "Status")

# cells |>
#   filter(cellsToUse) |>
#   filter(region == "region_5") |>
#   colTest(feature = "cellType", condition = "Status")  
```


# Are the cell type niches associated with progression?

```{r}
set.seed(51773)

# Cluster cells into spatial regions with similar composition.
cellsNiche <- lisaClust(
  cells,#[, cellsToUse],
  k = 50,
  r = 50,
  sigma = 20,
  spatialCoords = c("m.cx", "m.cy"),
  cellType = "cellType",
  regionName = "niche",
  cores = nCores
)
```



```{r}
# Test if the proportion of each region is associated
# with progression status.
testNiche <- colTest(
  cellsNiche[, cellsToUse],
  feature = "niche",
  condition = "Status"#,
  #type = "wilcox"
)

testNiche
```

```{r}
sort(table(cellsNiche[,cellsNiche$niche=="region_49"]$cellType))
```


```{r, fig.height=5, fig.width=5}
# Visualise the enrichment of each cell type in each region
regionMap(cells, cellType = "cellType", region = "niche", limit = c(0.2, 10))+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```



```{r}
tab <- chisq.test(table(cellsNiche$cellType, cellsNiche$niche))$res

use = rownames(testNiche)[1:10]

tab["T_cell_CD8",use]

sort(tab[,"region_49"])

```



# What if we hadn't clustered down to CD8 T cells?


```{r}
# Can we use mutate instead?

cells$cellTypeMergeTcells <- cells |>
  colData() |>
  as.data.frame() |>
  mutate(cellTypeMergeTcells = factor(case_when(
      cellType == "T_cell_CD8" ~ "T_cell",
      cellType == "T_cell_CD4" ~ "T_cell",
      # cellType == "CK_low_tumour" ~ "Tumour",
      # cellType == "Luminal" ~ "Tumour",
      # cellType == "Basal" ~ "Tumour",
      TRUE ~ cellType
  ))) |> 
  pull(cellTypeMergeTcells) 
  
```





# SpatioMark

```{r}

cells <- getDistances(cells,
  cellType = "cellTypeMergeTcells",
  spatialCoords = c("m.cx", "m.cy"),
  redDimName = "distancesTcells"
)

cells <- getAbundances(cells,
  r = 50,
  cellType = "cellTypeMergeTcells",
  spatialCoords = c("m.cx", "m.cy"),
  redDimName = "abundancesTcells",
)

stateChangesTcells <- calcStateChanges(
  cells,
  assay = "norm",
  cellType = "cellTypeMergeTcells",
  type = "distancesTcells",
  minCells = 5)


stateMatTcells <- prepMatrix(stateChangesTcells, replaceVal = NA, column = "coef")

stateMatTcells[stateMatTcells==Inf] <- NA
stateMatTcells <- stateMatTcells[,colMeans(is.na(stateMatTcells[rownames(prop),]))<0.4]


stateResultsTcells <- colTest(stateMatTcells[rownames(prop), ], droplevels(clinical[rownames(prop), "Status"]))

stateResultsTcells

stateResultsTcells[grep("CD8", stateResultsTcells$cluster),]


stateResultsTcells[grep("T_cell__Tumour__CD8", stateResultsTcells$cluster),]

boxplot(stateMatTcells[rownames(prop), "T_cell__Tumour__CD8"]~ droplevels(clinical[rownames(prop), "Status"]))
abline(h = 0)

```



```{r}

use <- cellsToUse & cells$cellTypeMergeTcells=="T_cell"

x <- reducedDim(cells, "distancesTcells")[use,"Tumour"]

y <- assay(cells,"norm")["CD8",use]

plot(x,y)

```







```{r}

data.frame(colData(cells),reducedDim(cells, "abundancesTcells"), t(assay(cells,  "norm")))|>
  
  filter(cellTypeMergeTcells %in% "T_cell", cellsToUse, !is.na(Tumour)) |>
  mutate(bin = factor(cut(Tumour,c(0,2,4,6,8,10,100),right = FALSE)))|>
  group_by(imageID,bin,Status) |>
  summarise(gene = mean(CD8)) |>
  #mutate(gene = CD8) |> ungroup()|>
  ggplot(aes(x = bin, y = gene, fill = Status)) + geom_boxplot(alpha = 0.5)  + 
    geom_jitter(aes(color = Status), 
              position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.9), 
              size = 2, alpha = 0.7) + geom_smooth(aes(as.numeric(bin), gene, colour = Status),method = "lm", se = FALSE)


data.frame(colData(cells),reducedDim(cells, "distancesTcells"), t(assay(cells, "norm"))) |>
  
  filter(cellTypeMergeTcells %in% "T_cell", cellsToUse, !is.na(Tumour)) |>
  mutate(bin = factor(cut(Tumour,c(0,50,100,150,200,1000),right = FALSE))) |>
  filter(!is.na(bin))|>
  group_by(imageID,bin , Status) |>
  summarise(gene = mean(CD8)) |>
  ggplot(aes(x = bin, y = gene, fill = Status)) + geom_boxplot(alpha = 0.5) + 
    geom_jitter(aes(color = Status), 
              position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.9), 
              size = 2, alpha = 0.7) + geom_smooth(aes(as.numeric(bin), gene, colour = Status),method = "lm", se = FALSE)

```

```{r}

data.frame(colData(cells),reducedDim(cells, "distancesTcells"), t(assay(cells, "norm"))) |>
  
  filter(cellTypeMergeTcells %in% "T_cell", cellsToUse, !is.na(Tumour)) |>
  mutate(bin = factor(cut(Tumour,
                          #seq(0,200,25),
                          c(0,50,1000),
                          #c(0,50,100,150,200,1000),
                          right = FALSE))) |>
  filter(!is.na(bin))|>
  group_by(bin , Status) |>
  summarise(gene = (CD8)) |>
  ggplot(aes(x = bin, y = gene, fill = Status)) + geom_violin(alpha = 0.5) + 
    geom_jitter(aes(color = Status), 
              position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.9), 
              size = 2, alpha = 0.7) + geom_smooth(aes(as.numeric(bin), gene, colour = Status),method = "lm", se = FALSE) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```


```{r}
data.frame(colData(cells),reducedDim(cells, "distancesTcells"), t(assay(cells, "norm"))) |>
  
  filter(cellTypeMergeTcells %in% "T_cell", cellsToUse, !is.na(Tumour)) |>
  
  ggplot(aes(pmin(Tumour,200), CD8, colour = Status)) + geom_point() + geom_smooth()
```




```{r}
p <- plotStateChanges(
  cells = cells,
  type = "distancesTcells",
  image = "Point2312_pt1064_20700",
  from = "T_cell",
  to = "Tumour",
  marker = "CD8",
  spatialCoords = c("m.cx", "m.cy"),
  assay = "norm",
  cellType = "cellTypeMergeTcells",
  size = 1,
  shape = 19,
  interactive = FALSE,
  plotModelFit = TRUE,
  method = "lm")

p
```




# Gene in cell in region

```{r}

data <- data.frame(colData(cells),t(assay(cells,  "norm")))|>
  filter(imageID %in% rownames(prop), cellTypeMergeTcells=="T_cell") |>
  group_by(imageID, domain, Status) |>
  summarise(gene = mean(CD8))

test = NULL
for(i in unique(data$domain)){
test[[i]] <- t.test(gene~Status, data[data$domain==i,])
} 

data.frame(colData(cells),t(assay(cells,  "norm")))|>
  filter(imageID %in% rownames(prop), cellTypeMergeTcells=="T_cell") |>
  group_by(imageID, domain, Status) |>
  summarise(gene = mean(CD8)) |>
  ggplot(aes(y=gene,x=domain, colour = Status))+
  geom_boxplot()
  
test

cells$typeRegion <- paste(cells$cellTypeMergeTcells, cells$domain, sep = "__")

data <- scFeatures(assay(cells, "norm"), 
                   feature_types = c("gene_mean_celltype"),
                   sample = cells$imageID,
                   celltype = cells$typeRegion)

testTypeRegion <- colTest(data[["gene_mean_celltype"]][rownames(prop),], as.character(clinical[rownames(prop), "Status"]))
testTypeRegion
testTypeRegion[grep("T_cell",rownames(testTypeRegion)),]

boxplot(data[["gene_mean_celltype"]][rownames(prop),"T_cell__region_1--CD8"]~as.character(clinical[rownames(prop), "Status"]))


```




<!-- # ClassifyR: Classification -->

<!-- Our ClassifyR package, [https://github.com/SydneyBioX/ClassifyR](https://github.com/SydneyBioX/ClassifyR), formalises a convenient framework for evaluating classification in R. We provide functionality to easily include four key modelling stages; Data transformation, feature selection, classifier training and prediction; into a cross-validation loop. Here we use the `crossValidate` function to perform 100 repeats of 5-fold cross-validation to evaluate the performance of an elastic net model applied to three quantification of our MIBI-TOF data; cell type proportions, average mean of each cell type and region proportions. -->





<!-- ```{r message=FALSE, warning=FALSE} -->
<!-- # Create list to store data.frames -->
<!-- data <- list() -->

<!-- # Add proportions of each cell type in each image -->
<!-- data[["props"]] <- getProp(cells, "clusters") -->

<!-- # Add pair-wise associations -->
<!-- data[["dist"]] <- getPairwise( -->
<!--   cells, -->
<!--   spatialCoords = c("m.cx", "m.cy"), -->
<!--   cellType = "clusters", -->
<!--   Rs = c(20, 50, 100), -->
<!--   sigma = 50, -->
<!--   cores = nCores -->
<!-- ) -->
<!-- data[["dist"]] <- as.data.frame(data[["dist"]]) -->


<!-- # Add proportions of each region in each image -->
<!-- # to the list of dataframes. -->
<!-- data[["regions"]] <- getProp(cells, "region") -->

<!-- # Subset data images with progression status and NA clinical variables. -->
<!-- measurements <- lapply(data, function(x) x[imagesToUse, ]) -->

<!-- # Set seed -->
<!-- set.seed(51773) -->

<!-- # Perform cross-validation of an elastic net model -->
<!-- # with 100 repeats of 5-fold cross-validation. -->
<!-- cv <- crossValidate( -->
<!--   measurements = measurements, -->
<!--   outcome = clinical[imagesToUse, "Status"], -->
<!--   classifier = "GLM", -->
<!--   nFolds = 5, -->
<!--   nRepeats = 100, -->
<!--   nCores = nCores -->
<!-- ) -->
<!-- ``` -->





<!-- ## Visualise cross-validated prediction performance -->

<!-- Here we use the `performancePlot` function to assess the AUC from each repeat of the 5-fold cross-validation. We see that the lisaClust regions appear to capture information which is predictive of progression status of the patients. -->

<!-- ```{r} -->
<!-- # Calculate AUC for each cross-validation repeat and plot. -->
<!-- performancePlot( -->
<!--   cv, -->
<!--   metric = "AUC", -->
<!--   characteristicsList = list(x = "Assay Name") -->
<!-- ) -->
<!-- ``` -->


<!-- # Summary -->

<!-- Here we have used a pipeline of our spatial analysis R packages to demonstrate an easy way to segment, cluster, normalise, quantify and classify high dimensional in situ cytometry data all within R. -->



<!-- ```{r} -->

<!-- cor_between_channels <- function(img) { -->
<!--   channels <- dimnames(img)[[3]] -->
<!--   corr <- NULL -->

<!--   reshaped <- apply(img, 3, as.vector) -->

<!--   for (i in channels) { -->
<!--     for (j in channels) { -->
<!--       # Flatten each colour channel into a vector -->
<!--       v1 <- as.vector(img[,,i]) -->
<!--       v2 <- as.vector(img[,,j]) -->

<!--       relationship <- paste(i,j,sep = "__") -->
<!--       corr[relationship] <- cor(v1, v2) -->
<!--           } -->
<!--   } -->

<!--   return(corr) -->
<!-- } -->


<!-- # Apply to all images -->
<!-- cor_list <- lapply(images[1:2], cor_between_channels) -->




<!-- ``` -->



```{r}
# make_channel_pairs <- function(channel_names) {
#   combos <- combn(channel_names, 2, simplify = FALSE)
#   named_list <- setNames(
#     lapply(combos, identity),
#     sapply(combos, function(x) paste(x, collapse = "__"))
#   )
#   return(named_list)
# }
# 
# channelPairs <- make_channel_pairs(dimnames(images[[1]])[[3]])
# 
# spatstat.explore::dendensity(img[,,1])
# 
# function(img, pairs){
#   use <- sample(ncol(img)*nrow(img), 1000)
#  corr <- lapply(pairs, function(x){
#    cor(as.vector(img[,,x[1]])[use], as.vector(img[,,x[2]])[use])
#  })
# }
# 
# disc <- makeBrush(21, shape='disc')
# smoothImages <- BiocParallel::bplapply(images, function(x){
#   apply(x,3,function(img){
#     filter2(img, disc)
#   })
# }, BPPARAM = BPPARAM)
# 
# correlations <- lapply(images, function(img){
# unlist(lapply(channelPairs, function(x){
#   cor(as.vector(img[,,x[1]]), as.vector(img[,,x[2]]), use = "complete")
# }))})
# 
# corr <- do.call("rbind", correlations)
# tests <- apply(corr[rownames(prop),], 2, function(x){
#   t.test(x~clinical[rownames(prop), "Status"])$stat
# })


CD8_PanKRT <- lapply(images[rownames(prop)], function(img){
  disc <- makeBrush(51, shape='disc')
  # CD8 <- gblur((img[,,"CD8"]), 5)
  # ER <- gblur((img[,,"ECAD"]), 5)
 CD8 <- filter2((img[,,"CD8"]), disc)
 PanKRT <- filter2((img[,,"PanKRT"]), disc)
 cor(as.vector(CD8), as.vector(PanKRT))

#   CD8 <- imager::correlate(imager::as.cimg(as.matrix(img[,,"CD8"])),imager::as.cimg(disc))
#   CD8 <- as.matrix(CD8)
#
# #  ER <- imager::correlate(imager::as.cimg(as.matrix(img[,,"ER"])),imager::as.cimg(disc))
# #  ER <- as.matrix(ER)
#
#   ECAD <- imager::correlate(imager::as.cimg(as.matrix(img[,,"ECAD"])),imager::as.cimg(disc))
#   ECAD <- as.matrix(ECAD)

  #corr <- cor(as.vector(CD8), as.vector(ECAD), use = "complete")
  #corr
 # compute_top_right_proportions_fast(cbind(as.vector(CD8), as.vector(ECAD)), 0.33)[1,2]

})

CD8_PanKRT <- unlist(CD8_PanKRT)


boxplot(CD8_PanKRT[rownames(prop)]~clinical[rownames(prop), "Status"])

t.test(CD8_PanKRT[rownames(prop)]~clinical[rownames(prop), "Status"])

```
```{r}



compute_top_right_proportions_fast <- function(mat, threshold = 0.5) {
  # Min-max scale each column
trim_99 <- function(x) {
q99 <- quantile(x, 0.99, na.rm = TRUE)
x[x > q99] <- q99
 x
}
 mat <- apply(mat, 2, trim_99)


  scaled <- sweep(mat, 2, apply(mat, 2, min), "-")
  scaled <- sweep(scaled, 2, apply(mat, 2, max) - apply(mat, 2, min), "/")

  # Logical matrix: TRUE if value > threshold
  mask <- scaled > threshold

  # Compute pairwise proportions using cross-product
  proportions <- (t(mask) %*% mask) / nrow(mat)

  # Set diagonal to 0
  diag(proportions) <- 0

  # Add names if available
  if (!is.null(colnames(mat))) {
    colnames(proportions) <- colnames(mat)
    rownames(proportions) <- colnames(mat)
  }

  return(proportions)
}






compute_colour_correlations_fast <- function(image_array, patch_size = 8) {
  h <- dim(image_array)[1]
  w <- dim(image_array)[2]
  ch <- dim(image_array)[3]

  # Crop image to fit patch size
  h_crop <- floor(h / patch_size) * patch_size
  w_crop <- floor(w / patch_size) * patch_size
  image_array <- image_array[1:h_crop, 1:w_crop, ]

  # Reshape into patches
  patches <- array(image_array, dim = c(patch_size, h_crop / patch_size, patch_size, w_crop / patch_size, ch))
  patches <- aperm(patches, c(2, 4, 5, 1, 3))  # [patch_y, patch_x, channel, patch_h, patch_w]

  # Compute mean intensity per patch per channel
  patch_means <- apply(patches, c(1, 2, 3), mean)  # [patch_y, patch_x, channel]
  patch_means <- matrix(aperm(patch_means, c(1, 2, 3)), ncol = ch)  # [num_patches, channels]

  # Correlation matrix
  #cor(patch_means)

  # Continuous mutual information
  compute_top_right_proportions_fast(patch_means, threshold = 0.1)

}


corrs <- lapply(images[rownames(prop)], function(img){
  compute_colour_correlations_fast(img, patch_size = 50)
})

corArray <- abind::abind(corrs, along = 3)

corTest <- apply(corArray[,,rownames(prop)], c(1,2), function(x){
  tryCatch({t.test(x~clinical[rownames(prop), "Status"])$statistic}, error = function(e)NA)
})

colnames(corTest) <- rownames(corTest) <- dimnames(images[[1]])[[3]]


# Assume `mat` is your matrix with row and column names
vec <- as.vector(corTest)
names(vec) <- outer(rownames(corTest), colnames(corTest), paste, sep = "__")
names(vec) <- as.vector(names(vec))


sort(vec[grep("CD8",names(vec))]) |> head()

corArray2 <- corArray
colnames(corArray2) <- rownames(corArray2) <- dimnames(images[[1]])[[3]]

boxplot(corArray2["PanKRT","CD8",rownames(prop)]~clinical[rownames(prop), "Status"])
t.test(corArray2["PanKRT","CD8",rownames(prop)]~clinical[rownames(prop), "Status"])

boxplot(corArray2["ECAD","CD8",rownames(prop)]~clinical[rownames(prop), "Status"])
t.test(corArray2["ECAD","CD8",rownames(prop)]~clinical[rownames(prop), "Status"])





```


<!-- ```{r} -->
<!-- # Set patch size -->
<!-- patch_height <- 16 -->
<!-- patch_width <- 16 -->

<!-- # Get dimensions -->
<!-- img_dims <- dim(img) -->
<!-- h <- img_dims[1] -->
<!-- w <- img_dims[2] -->
<!-- channels <- img_dims[3] -->

<!-- # Function to compute patch means -->
<!-- get_patch_means <- function(img, ph, pw) { -->
<!--   h_patches <- floor(h / ph) -->
<!--   w_patches <- floor(w / pw) -->

<!--   # Initialize output: patch x channel -->
<!--   patch_means <- array(NA, dim = c(h_patches, w_patches, channels)) -->

<!--   for (ch in 1:channels) { -->
<!--     for (i in 1:h_patches) { -->
<!--       for (j in 1:w_patches) { -->
<!--         patch <- img[((i - 1) * ph + 1):(i * ph), ((j - 1) * pw + 1):(j * pw), ch] -->
<!--         patch_means[i, j, ch] <- mean(patch) -->
<!--       } -->
<!--     } -->
<!--   } -->
<!--   return(patch_means) -->
<!-- } -->

<!-- # Compute means -->
<!-- means <- get_patch_means(img, patch_height, patch_width) -->


<!-- ``` -->




# sessionInfo

```{r}
sessionInfo()
```